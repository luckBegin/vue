<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<style>
		*{
			margin : 0px;
			padding:  0px;
			overflow: hidden;
		}
		html , body{
			width : 100%;
			height: 100%;
		}
		*{
			margin:0px;
			padding: 0px;
		}
		html , body{
			width: 100% ;
			height: 100% ;
		}
		.canvas_bgp{
			width:100% ;
			height: 100%;
			position: absolute;
			top: 0;
			left: 0;
			margin: 0px;
			padding: 0px;
		}
		#canvas{
			position: absolute;
			top: 0;
			left: 0;
			z-index: 1;
		}
	</style>
</head>
<body>
<canvas id="canvas">

</canvas>
<img src="./bg.png" class="canvas_bgp">
<script>
	var wWidth = document.body.clientWidth ;

	var wHeight = document.body.clientHeight ;

	var canvas = document.getElementById("canvas") ;

	canvas.width = wWidth ;

	canvas.height = wHeight ;

	var ctx = canvas.getContext("2d") ;

	var image = new Image() ;

	var defaultImg =  new Image() ;

	defaultImg.src = './2.jpg' ;

	var renderSize = 30 ;

	var renderGap = 2 ;
	var gap = 250 ;

	var dots = [] ;

	image.src = './a.png' ;

	image.onload = function(){
		ctx.drawImage(image , 0 , 0) ;

		var data = ctx.getImageData( 0 , 0 , wWidth , wHeight ) ;

		dots = getDots(data) ;

		init();

	};

	var getDots = function( data ){
		ctx.clearRect(0,0,canvas.width , canvas.height);

		var _dots = [];
		for(var x=0 ; x < data.width ; x += renderSize + renderGap ){

			for(var y = 0;y<data.height ; y += renderSize + renderGap ){

				var i = ( y * data.width + x) * 4 ;

				if(data.data[i] >= 128){
					var dot = new Dot( x + 3 , y + 3 , 0 , 3 , x , y );
					_dots.push(dot);
				}
			}
		}
		return _dots;
	};

	var Dot = function(centerX , centerY , centerZ , gapX , gapY){

		// 打乱后的坐标
		this.dx = centerX;
		this.dy = centerY;
		this.dz = centerZ;

		// 打乱前的坐标
		this.z = centerZ;
		this.x = centerX;
		this.y = centerY;

	};

	// 粒子的绘制方法
	Dot.prototype = {
		paint:function(){
			ctx.save();

			ctx.beginPath();

			var scale = gap/(gap + this.z);

			ctx.drawImage( defaultImg , canvas.width/2 + (this.x-canvas.width/2)*scale , canvas.height/2 + (this.y-canvas.height/2) * scale , renderSize , renderSize );

			ctx.restore();
		}
	};

	function init(){
		// 将粒子打乱并进行绘制

		dots.forEach( (_this) => {
			_this.x = Math.random()*canvas.width;
			_this.y = Math.random()*canvas.height;
			_this.z = Math.random()*gap*2 - gap;

			_this.tx = Math.random()*canvas.width;
			_this.ty = Math.random()*canvas.height;
			_this.tz = Math.random()*gap*2 - gap;
			_this.paint();
		});
		// 实现动画效果
		animate();
	};

	// 标记动画的方向
	var derection = true ;

	// 动画实现
	function animate(){
		// 开始动画之前先清空画布
		ctx.clearRect(0,0,canvas.width , canvas.height);

		// 遍历粒子数组
		dots.forEach(function(item){
			var dot = item;

			// direction为true时代表将打乱的粒子组成文字 , 反之则是将组成的文字重新打乱
			if(derection === true ){
				// 判断是否组成文字
				if( Math.abs(dot.dx - dot.x) < 0.1 && Math.abs(dot.dy - dot.y ) < 0.1 && Math.abs(dot.dz - dot.z) < 0.1){
					derection = true  ;
				}else{
					dot.x = dot.x + (dot.dx - dot.x) * 0.04;
					dot.y = dot.y + (dot.dy - dot.y) * 0.04;
					dot.z = dot.z + (dot.dz - dot.z) * 0.04;
				};
			}else{
				if (Math.abs(dot.tx - dot.x) < 0.1 && Math.abs(dot.ty - dot.y) < 0.1 && Math.abs(dot.tz - dot.z)<0.1) {
					derection = true;
				} else {
					dot.x = dot.x + (dot.tx - dot.x) * 0.02 ;
					dot.y = dot.y + (dot.ty - dot.y) * 0.02 ;
					dot.z = dot.z + (dot.tz - dot.z) * 0.02 ;
				};
			};
			// 重新绘制
			dot.paint();
		});
		requestAnimationFrame(animate);
	};
</script>
</body>
</html>